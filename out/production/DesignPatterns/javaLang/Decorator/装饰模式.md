## 装饰模式
> 动态地给对象添加一些额外的职责，就增加功能来说，装饰模式相比生成子类更为灵活

## 使用场景
需要透明且动态扩展类的应用时

## 角色介绍
* **Component：** 抽象组件，可以是接口或抽象类，其充当的就是被装饰的原始对象
* **ConcreteComponent：** 组件具体实现类，该类是Component的具体实现，也是我们装饰的具体对象
* **Decorator：** 抽象装饰者，其承担的职责就是装饰我们的组件对象，其内部一定要有一个指向
组件对象的引用。在大多数情况下，该类是抽象类，需要根据不同的装饰逻辑实现不同的具体子类。
如果装饰逻辑单一，只有一个的情况下，我们可以省略该类，直接作为具体的装饰者。
* **ConcreteDecoratorA：** 装饰者具体实现类，只是对抽象装饰者做具体实现。
* **ConcreteDecoratorB：** 同上

## 源码中的装饰模式
Context